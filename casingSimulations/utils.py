import json
import numpy as np
import time
import datetime
from discretize import utils
import properties
import casingSimulations


def load_properties(filename):
    """
    Open a json file and load the properties into the target class

    As long as there are no namespace conflicts, the target __class__
    will be stored on the properties.HasProperties registry and may be
    fetched from there.

    :param str filename: name of file to read in
    """
    with open(filename, 'r') as outfile:
        jsondict = json.load(outfile)
        data = properties.HasProperties.deserialize(jsondict, trusted=True)
    return data


# grab 2D slices
def face3DthetaSlice(mesh3D, j3D, theta_ind=0):
    """
    Grab a theta slice through a 3D field defined on faces
    (x, z components), consistent with what would be found from a
    2D simulation

    :param discretize.CylMesh mesh3D: 3D cyl mesh
    :param numpy.ndarray j3D: vector of fluxes on mesh
    :param int theta_ind: index of the theta slice that you want
    """
    j3D_x = j3D[:mesh3D.nFx].reshape(mesh3D.vnFx, order='F')
    j3D_z = j3D[mesh3D.vnF[:2].sum():].reshape(mesh3D.vnFz, order='F')

    j3Dslice = np.vstack([
        utils.mkvc(j3D_x[:, theta_ind, :], 2),
        utils.mkvc(j3D_z[:, theta_ind, :], 2)
    ])

    return j3Dslice


def edge3DthetaSlice(mesh3D, h3D, theta_ind=0):
    """
    Grab a theta slice through a 3D field defined on edges
    (y component), consistent with what would be found from a
    2D simulation

    :param discretize.CylMesh mesh3D: 3D cyl mesh
    :param numpy.ndarray h3D: vector of fields on mesh
    :param int theta_ind: index of the theta slice that you want
    """

    h3D_y = h3D[mesh3D.nEx:mesh3D.vnE[:2].sum()].reshape(
        mesh3D.vnEy, order='F'
    )

    return utils.mkvc(h3D_y[:, theta_ind, :])


def ccv3DthetaSlice(mesh3D, v3D, theta_ind=0):
    """
    Grab a theta slice through a 3D field defined at cell centers

    :param discretize.CylMesh mesh3D: 3D cyl mesh
    :param numpy.ndarray v3D: vector of fields on mesh
    :param int theta_ind: index of the theta slice that you want
    """

    ccv_x = v3D[:mesh3D.nC].reshape(mesh3D.vnC, order='F')
    ccv_y = v3D[mesh3D.nC:2*mesh3D.nC].reshape(mesh3D.vnC, order='F')
    ccv_z = v3D[2*mesh3D.nC:].reshape(mesh3D.vnC, order='F')

    return np.vstack([
        utils.mkvc(ccv_x[:, theta_ind, :], 2),
        utils.mkvc(ccv_y[:, theta_ind, :], 2),
        utils.mkvc(ccv_z[:, theta_ind, :], 2)
    ])


def writeSimulationPy(
    cp='CasingParameters.json',
    meshGenerator='MeshParameters.json',
    src='Source.json',
    physics='FDEM',
    fields_filename='fields.npy',
    directory='.',
    simulation_filename='simulation.py',
    includeDC=True,  # cheap, why not
    include2D=True  # cheap, why not
):

    sim_file = '/'.join([directory, simulation_filename])
    with open(sim_file, 'w') as f:

        # add comment stating when the file was generated
        f.write(
            "# Autogenerated at {date} on version {version}\n".format(
                date=datetime.datetime.now().isoformat(),
                version=casingSimulations.__version__
            )
        )

        # write the imports
        f.write(
            "import casingSimulations\nimport numpy as np\n"
        )

        # write the simulation
        f.write(
            """
# Set up the simulation
sim = casingSimulations.run.Simulation{physics}(
    cp='{cp}',
    meshGenerator='{meshGenerator}',
    src='{src}',
    fields_filename='{fields_filename}'
)
\n""".format(
                physics=physics,
                cp=cp,
                meshGenerator=meshGenerator,
                src=src,
                fields_filename=fields_filename
            )
        )

        # write the run
        f.write(
            "# run the simulation \nfields = sim.run()\n"
        )

        # if we are including a 2D simulation
        if include2D:
            f.write(
                """
# Set up a 2D simulation for the same source location
mesh2D = sim.meshGenerator.copy()
mesh2D.hy = np.r_[2*np.pi]
src2D = getattr(casingSimulations.sources, sim.src.__class__.__name__)(
    cp=sim.cp,
    meshGenerator=mesh2D,
)
sim2D = casingSimulations.run.Simulation{physics}(
    cp=sim.cp,
    meshGenerator=mesh2D,
    src=src2D,
    fields_filename='fields2D.npy',
    filename='simulation2D.json'
)
\n""".format(
                    physics=physics,
                )
            )

        # run the 2D simulation
            f.write(
                "# run the 2D simulation \nfields2D = sim2D.run()\n"
            )

        # if we are including a DC simulation
        if includeDC:
            f.write(
                """
# Set up DC survey for the same source location
csz = sim.meshGenerator.csz
# make sure it is in the cell
src_a = sim.src.src_a_closest - np.r_[0., 0., csz/2.]
src_b = sim.src.src_b_closest - np.r_[0., 0., csz/2.]

simDC = casingSimulations.run.SimulationDC(
    filename='simulationDC.py',
    cp=sim.cp,
    meshGenerator=sim.meshGenerator,
    src_a=src_a,
    src_b=src_b
)\n"""
            )

            f.write(
                "# run the DC simulation \nfieldsDC = simDC.run()\n"
                )

    print('wrote {}'.format(sim_file))


def loadSimulationResults(
    directory='.',
    meshParameters='MeshParameters.json',
    casingParameters='ModelParameters.json',
    source='Source.json',
    fields='fields.npy',
    fieldsDC=None,
    fields2D=None
):
    print('Loading simulation in {}'.format(directory))
    # load up the properties
    meshGenerator = load_properties('/'.join([directory, meshParameters]))
    cp = load_properties('/'.join([directory, casingParameters]))
    src = load_properties('/'.join([directory, source]))

    # load up the numpy array of the soln
    field = np.load('/'.join([directory, fields]))

    # reconstruct the 3D simulation
    print('   repopulating 3D fields')
    t = time.time()
    sim = getattr(casingSimulations.run, 'Simulation{}'.format(src.physics))(
        cp=cp, meshGenerator=meshGenerator, src=src
    )
    sim.prob.model = sim.physprops.model

    if isinstance(
        sim,
        (
            casingSimulations.run.SimulationFDEM,
            casingSimulations.run.SimulationDC
        )
    ):
        sim._fields = sim.prob.fieldsPair(meshGenerator.mesh, sim.survey)[
            :, '{}Solution'.format(sim.formulation)
        ]
    elif isinstance(sim, casingSimulations.run.SimulationTDEM):
        sim._fields = sim.prob.fieldsPair(meshGenerator.mesh, sim.survey)[
            :, :, '{}Solution'.format(sim.formulation)
        ]

    print('   ... Done. Elapsed time : {}\n'.format(time.time()-t))

    simulations = (sim, )

    # reconstruct the 2D simulation
    if fields2D is not None:
        mesh2D = sim.meshGenerator.copy()
        mesh2D.hy = np.r_[2*np.pi]
        src2D = getattr(casingSimulations.sources, sim.src.__class__.__name__)(
            cp=sim.cp,
            meshGenerator=mesh2D,
        )
        sim2D = casingSimulations.run.SimulationTDEM(
            cp=sim.cp,
            meshGenerator=mesh2D,
            src=src2D,
            fields_filename=fields2D,
            filename='simulation2D.json'
        )
        sim2D.prob.model = sim2D.physprops.model

        print('    repopulating 2D fields')
        t = time.time()
        field2D = np.load('/'.join([directory, fields2D]))
        sim2D._fields = sim2D.prob.fieldsPair(
            sim2D.meshGenerator.mesh, sim2D.survey
        )
        sim2D._fields[:, '{}Solution'.format(sim2D.formulation)] = field2D
        print('   ... Done. Elapsed time : {}\n'.format(time.time()-t))

        simulations += (sim2D, )

    if fieldsDC is not None:
        # reconstruct the DC solution
        csz = sim.meshGenerator.csz
        # make sure it is in the cell
        src_a = sim.src.src_a_closest - np.r_[0., 0., csz/2.]
        src_b = sim.src.src_b_closest - np.r_[0., 0., csz/2.]

        simDC = casingSimulations.run.SimulationDC(
            filename='simulationDC.py',
            cp=sim.cp,
            meshGenerator=sim.meshGenerator,
            src_a=src_a,
            src_b=src_b
        )
        simDC.prob.model = simDC.physprops.model

        print('    repopulating DC fields')
        t = time.time()
        fieldDC = np.load('/'.join([simDir, fieldDC]))
        simDC._fields = simDC.prob.fieldsPair(
            simDC.meshGenerator.mesh, simDC.survey
        )

        simDC._fields[:, '{}Solution'.format(simDC.formulation)]
        print('   ... Done. Elapsed time : {}\n'.format(time.time()-t))

        simulations += (simDC, )

    return simulations
